\documentclass{article}

\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage[a4paper,landscape]{geometry}
\usepackage{algpseudocode}

\author{Виталий Кирсанов}

\begin{document}

\section{Важная памятка}

\begin{enumerate}
\item
Для доказательства взаимного исключения нужно показать, что ни один поток, находящийся где-либо во входном протоколе, не сможет
выйти из него, если критическая область уже занята каким-либо другим потоком.

\item
Для доказательства отсутствия livelocks нужно показать, что из всех потоков, находящихся во входном протоколе, найдётся хотя бы
один, который сможет преодолеть все этапы входного протокола независимо от того, на каких этапах находятся оставшиеся потоки, при
условии, что критическая область свободна, равно как и выходной протокол.

\item
Для доказательства отсутствия ненужных задержек нужно показать, что поток, находящийся во входном протоколе, сможет пройти все его
этапы при условии, что ни один другой поток не находится ни во входном протоколе, ни в критической секции, ни в выходном
протоколе. Вообще, кажется, что это частный случай предыдущего пункта.
\end{enumerate}

\section{location - разделяемый регистр}

Изначально я неправильно понял исправленную постановку задачи 3.5 и написал решение для подзадачи а) считая, что \emph{location} -
это разделяемая всеми процессами переменная (так, как утверждается в неисправленной версии задачи). Соответственно, инструкция $
LL() $ в одном процессе позволит в конце коцов другим выйти из цикла по инструкции $ SC() $.

Глобальный вариант для нижеследующей программы выглядит так:

\begin{displaymath}
\begin{matrix}
location = 0 \land \exists ! k, 1 \leq k \leq n : 7 \leq pc_k < 9 \\
\lor \\
location = \&mutex \land \forall i, 1 \leq i \leq n : pc_k < 7 \lor pc_k \geq 9
\end{matrix}
\end{displaymath}

\begin{algorithmic}[1]
\State $ LL(mutex, \_1) $                           \Comment $ location = \&mutex $
\Procedure{process}{p = 1..n}                       \Comment $ true $
    \While{$ true $}
        \While{$ SC(mutex, \_1) = 0 $}
            \State \textbf{skip}
        \EndWhile                                   \Comment $ location = 0 $
        \State \texttt{critical section}
        \State $ LL(mutex, \_1)  $                  \Comment $ true $
        \State \texttt{noncritical section}
    \EndWhile
\EndProcedure
\end{algorithmic}

\begin{enumerate}
\item Взаимное исключение следует из глобального инварианта. Действительно, допустим, что некий поток \( p \) вошёл
      в критическую зону (\( 7 \leq pc_p < 9\) ). Далее, пусть поток \( q \) пытается войти в ту же критическую зону. Для
      этого инструкция \( SC(mutex, \_1) \) на позиции 4 должна вернуть единицу. Но для этого необходимо, чтобы переменная
      \( location \) имела ненулевое значение, тогда как она в данный момент равна нулю. Поэтому после выполнения этой
      инструкции \( pc_q \) будет равен 5, что не противоречит глобальному инварианту. В результате мы имеем то, что 1)
      \( location = 0 \) тогда и только тогда, когда в критической зоне находится какой-либо поток и 2) этот поток единственен
      так как мы только что доказали, что ни один другой поток не может войти в критическую зону, если она уже занята.
\item livelock мог бы возникнуть, если для всех процессов инструкция $ SC() $ всегда бы возвращала 0.  Из определения
      инструкции $ SC() $ следует, что такое может быть, только если $ location \neq \&mutex $. Глобальный инвариант 
      усиливает это неравенство: $ location = 0 $. livelock в нашей программе можно описать предикатом $ \forall i,
      1 \leq i \leq n : 4 \leq pc_i \leq 6 $. Но если $ location = 0 $, то неизбежно должен найтись хотя бы один процесс,
      программный счётчик которого должен быть между 7-й (включительно) и 9-й (исключительно) строками программы (это следует
      из глобального предиката), что противоречит условию наличия livelock.
\item Излишняя задержка могла бы возникнуть, если некий процесс $ p $ пытался бы и не мог войти в критическую секцию, тогда как
      все остальные процессы находились бы вне критической секции и вне входного протокола ($ \exists p, 1 \leq p \leq n : pc_p
      = 4 \land \forall i, 1 \leq i \leq n, i \neq p : pc_i \geq 9 \land pc_i < 4 $). Из глобального инварианта отсюда следует,
      что $ location = \&mutex $. Но тогда инструкция $ SC() $ должна вернуть 1, что позволит процессу $ p $ войти в критическую
      зону без задержки.
\end{enumerate}

\section{location - собственный регистр}

В этой версии задачи мы считаем, что каждый процесс имеет \emph{свою} копию регистра $ location $ и что инструкция $ LL() $
загружает значение переменной и помещает адрес этой переменной в регистр $ location $ \emph{только} того процесса, который
выполнил эту инструкцию, тогда как инструкция $ SC() $ сбрасывает в ноль значения \emph{всех} регистров $ location $.

\subsection{Подзадача А}

Глобальный инвариант:
\begin{displaymath}
\begin{matrix}
occupied = true \implies \exists p, 1 \leq p \leq n : 9 \leq pc_p < 11 \\
\land \\
occupied = false \implies \forall i, 1 \leq i \leq n : pc_i < 9 \land pc_i \geq 11 \\
\end{matrix}
\end{displaymath}

\begin{algorithmic}[1]
\State $ occupied \gets false $
\Procedure{process}{p = 1 .. n}                         \Comment $ location_p = 0 $
    \While{ $ true $ }
        \Repeat
            \Repeat                                     \Comment $ true $
                \State $ LL(occupied, my\_occupied) $
            \Until{ $ my\_occupied = false $ }          \Comment $ my\_occupied = false \land (location_p = \&occupied \land
                                                                   occupied = false \lor location_p = 0) $
        \Until{ $  SC(occupied, true) = true $ }        \Comment $ location_p = 0 \land occupied = true $
        \State \texttt{critical section}
        \State $ occupied \gets false $                 \Comment $ location_p = 0 $
        \State \texttt{noncritical section}
    \EndWhile
\EndProcedure
\end{algorithmic}

\begin{enumerate}
\item Взаимное исключение. Пусть некий процесс $ p $ находится в критической секции ($ 9 \leq pc_p < 11 $). Тогда переменная
      $ occupied $ будет иметь значение $ true $. Покажем, что при этом любой другой поток не сможет выйти из входного протокола.
      Пусть другой поток $ q $ собирается выполнить шаги 6 и 7. После выполнения шага 6 значение переменной $ my\_occupied $
      будет равняться $ true $. Но тогда условие шага 7 вынудит поток вернуться к шагу 6. Таким образом поток $ q $ не сможет
      выйти из этого цикла до тех пор, пока $ occupied $ не станет $ false $. Предположим теперь, что $ pc_p = 8 $. Так как
      $ occupied = true $, то из предиката на шаге 7 следует, что $ location_q = 0 $. А это приведёт к тому, что инструкция
      $ SC() $ на шаге 8 вынудит поток $ q $ вернуться к шагу 4, что показывает, что поток $ q $ не войдёт в критическую секцию.
      Таким образом, находясь на любом шаге входного протокола, поток $ q $ не сможет войти в критическую секцию, пока там 
      находится поток $ p $.
\item Отсутствие livelocks. Livelock мог бы возникнуть, если бы ни один поток не находился в критической секции и по меньшей мере
      два из них пытались бы войти в неё ($ \forall i, 1 \leq i \leq n : pc_i < 9 \land pc_i \geq 11 $ и $ \exists p,q, 1 \leq
      p,q \leq n : 4 \leq pc_p < 9 \land 4 \leq pc_q < 9 $). Отсюда и из глобального инварианта следует, что переменная $ occupied
      $ неизбежна будет равна $ false $. Это говорит нам о том, что как поток $ p $ так и поток $ q $ смогут преодолеть цикл на
      шагах 6 и 7, так как переменные $ my\_occupied_p $ и $ my\_occupied_q $ будут обе равны $ flase $. Ну а, согласно определению
      функции $ SC() $, по крайней мере для одного из потоков результат выполнение проверки шага 8 будет положительным, что
      привет его в критическую секцию. Для случая, когда во входном протоколе находится более двух потоков рассуждения аналогичны:
      все они смогут преодолеть цикл на шагах 6 и 7, и ровно один из них преодолеет шаг 8.
\item Отсутстве ненужных задержек. Доказательство этого является частным случаем доказательства отсутсвия livelocks, когда во
      входном протоколе находится единственный поток.
\end{enumerate}

\subsection{Подзадача Б}

Думаю, справедливый алгоритм не может быть сделан с помощью этих унструкций.

\end{document}
